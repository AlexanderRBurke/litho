"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8807],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>l,MDXProvider:()=>d,mdx:()=>g,useMDXComponents:()=>c,withMDXComponents:()=>m});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e}).apply(this,arguments)}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),m=function(e){return function(n){var t=c(n.components);return o.createElement(e,r({},n,{components:t}))}},c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),m=c(t),d=a,h=m["".concat(s,".").concat(d)]||m[d]||u[d]||r;return t?o.createElement(h,i(i({ref:n},l),{},{components:t})):o.createElement(h,i({ref:n},l))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,s=new Array(r);s[0]=h;var i={};for(var p in n)hasOwnProperty.call(n,p)&&(i[p]=n[p]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<r;l++)s[l]=t[l];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}h.displayName="MDXCreateElement"},13919:(e,n,t)=>{function o(e){return!0===/^(\w*:|\/\/)/.test(e)}function a(e){return void 0!==e&&!o(e)}t.d(n,{b:()=>o,Z:()=>a})},44996:(e,n,t)=>{t.r(n),t.d(n,{useBaseUrlUtils:()=>r,default:()=>s});var o=t(52263),a=t(13919);function r(){var e=(0,o.default)().siteConfig,n=(e=void 0===e?{}:e).baseUrl,t=void 0===n?"/":n,r=e.url;return{withBaseUrl:function(e,n){return function(e,n,t,o){var r=void 0===o?{}:o,s=r.forcePrependBaseUrl,i=void 0!==s&&s,p=r.absolute,l=void 0!==p&&p;if(!t)return t;if(t.startsWith("#"))return t;if((0,a.b)(t))return t;if(i)return n+t;var m=t.startsWith(n)?t:n+t.replace(/^\//,"");return l?e+m:m}(r,t,e,n)}}}function s(e,n){return void 0===n&&(n={}),(0,r().withBaseUrl)(e,n)}},90630:(e,n,t)=>{t.r(n),t.d(n,{frontMatter:()=>i,contentTitle:()=>p,metadata:()=>l,toc:()=>m,default:()=>d});var o=t(87462),a=t(63366),r=(t(67294),t(3905)),s=t(44996),i={id:"prop-matching",title:"Matching @Prop"},p=void 0,l={unversionedId:"testing/prop-matching",id:"testing/prop-matching",isDocsHomePage:!1,title:"Matching @Prop",description:"Checkout the getting started section to setup the test environment correctly.",source:"@site/../docs/testing/prop-matching.mdx",sourceDirName:"testing",slug:"/testing/prop-matching",permalink:"/docs/testing/prop-matching",editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/testing/prop-matching.mdx",version:"current",frontMatter:{id:"prop-matching",title:"Matching @Prop"},sidebar:"mainSidebar",previous:{title:"Sub-Component Testing",permalink:"/docs/testing/subcomponent-testing"},next:{title:"Matching @TreeProp",permalink:"/docs/testing/testing-treeprops"}},m=[{value:"Complex Components",id:"complex-components",children:[{value:"Testing complex components",id:"testing-complex-components",children:[]}]},{value:"Props Matching with <code>@TestSpec</code>",id:"props-matching-with-testspec",children:[{value:"Using <code>@TestSpec</code>",id:"using-testspec",children:[]},{value:"Advanced Matchers",id:"advanced-matchers",children:[]},{value:"Matching Matchers",id:"matching-matchers",children:[]}]},{value:"A Note on Buck",id:"a-note-on-buck",children:[]},{value:"TL;DR",id:"tldr",children:[]}],c={toc:m};function d(e){var n=e.components,t=(0,a.Z)(e,["components"]);return(0,r.mdx)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.mdx)("div",{parentName:"div",className:"admonition-heading"},(0,r.mdx)("h5",{parentName:"div"},(0,r.mdx)("span",{parentName:"h5",className:"admonition-icon"},(0,r.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.mdx)("div",{parentName:"div",className:"admonition-content"},(0,r.mdx)("p",{parentName:"div"},"Checkout the ",(0,r.mdx)("a",{parentName:"p",href:"unit-testing"},"getting started")," section to setup the test environment correctly."))),(0,r.mdx)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.mdx)("div",{parentName:"div",className:"admonition-heading"},(0,r.mdx)("h5",{parentName:"div"},(0,r.mdx)("span",{parentName:"h5",className:"admonition-icon"},(0,r.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.mdx)("div",{parentName:"div",className:"admonition-content"},(0,r.mdx)("p",{parentName:"div"},"Checkout the ",(0,r.mdx)("a",{parentName:"p",href:"subcomponent-testing"},(0,r.mdx)("strong",{parentName:"a"},"sub-component testing"))," section before diving into\nprop matching."))),(0,r.mdx)("p",null,"In this article, we will drill a bit deeper and explore TestSpecs as a way to test individual\nprops of those components, even if we don't know all of them."),(0,r.mdx)("h2",{id:"complex-components"},"Complex Components"),(0,r.mdx)("p",null,"Composability is one of the big strengths Litho has to offer. It allows you to\nencapsulate your logic in small components and compose them together\neffortlessly into larger ones. But despite all good efforts, sometimes there is\nno clear dividing line and your component may grow beyond its original scope."),(0,r.mdx)("p",null,"Having more complex components shouldn't prevent you from using them\nconfidently. That's why we have a set of powerful APIs to test your components\nno matter the size."),(0,r.mdx)("p",null,"For this example, let's consider this LayoutSpec:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"@LayoutSpec\npublic class ComplexComponentSpec {\n  @OnCreateLayout\n  static Component onCreateLayout(\n      ComponentContext c,\n      @Prop StoryProps<ComplexAttachment> storyProps,\n      @Prop ImageRequest imageRequest,\n      @Prop DraweeController draweeController,\n      @Prop String title,\n      @Prop(resType = ResType.DIMEN_TEXT) int titleTextSize,\n      @Prop int visiblePhotoCount,\n      @Prop(optional = true) Artist favoriteArtist,\n      @Prop(optional = true) boolean shouldHavePuppies) {\n    return Row.create(c).build();\n  }\n}\n")),(0,r.mdx)("h3",{id:"testing-complex-components"},"Testing complex components"),(0,r.mdx)("p",null,"When we look at the props of our ",(0,r.mdx)("inlineCode",{parentName:"p"},"ComplexComponent"),", we see a lot of opaque\nobjects that we may have trouble getting ahold of for our tests. ",(0,r.mdx)("inlineCode",{parentName:"p"},"StoryProps"),"\nmight be something we obtain through some dependency injection mechanism. A\n",(0,r.mdx)("inlineCode",{parentName:"p"},"DraweeController")," is an implementation detail we shouldn't have to worry about\nfor ensuring that the component tree has the right shape."),(0,r.mdx)("p",null,"However, if you remember the ",(0,r.mdx)("inlineCode",{parentName:"p"},"SubComponent.of")," API, we need to specify all\nnon-optional props for it to succeed. Let's see what this would look like:"),(0,r.mdx)("img",{src:(0,s.default)("/images/complex-component-0.svg"),align:"right",width:"200px",className:"white-background"}),(0,r.mdx)("br",null),(0,r.mdx)("p",null,"As always, we create a standard JUnit test suite and run it with a\n",(0,r.mdx)("inlineCode",{parentName:"p"},"RobolectricTestRunner"),"-compatible implementation like ",(0,r.mdx)("inlineCode",{parentName:"p"},"LithoTestRunner"),"."),(0,r.mdx)("p",null,"For the purpose of this article, we assume that we have a ",(0,r.mdx)("inlineCode",{parentName:"p"},"FeedItemComponent"),"\nthat contains our ",(0,r.mdx)("inlineCode",{parentName:"p"},"ComplexComponent"),". The ",(0,r.mdx)("inlineCode",{parentName:"p"},"FeedItemComponent")," contains the logic\nfor populating our complex props which we want to verify."),(0,r.mdx)("br",{clear:"right"}),(0,r.mdx)("br",null),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'@Test\npublic void testComplexSubComponent() {\n  final ComponentContext c = mLithoViewRule.getContext();\n  final Component<FeedItemComponent> component = makeComponent("Two Brothers");\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, legacySubComponent(SubComponent.of(\n          // ERROR: This fails at runtime as we haven\'t provided all\n          // required parameters.\n          ComplexComponent.create(c)\n            .title("Two Brothers")\n            .build()))));\n}\n\n')),(0,r.mdx)("p",null,"Sadly, this test fails with this error message:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"java.lang.IllegalStateException: The following props are not marked as optional\nand were not supplied: [storyProps, imageRequest, draweeController,\ntitleTextSize, visiblePhotoCount]\n")),(0,r.mdx)("p",null,"But what if we can't provide these props in our tests? Or if we don't\nwant to test implementation details like the image loading controller?"),(0,r.mdx)("p",null,"We could simply choose not to test any props at all and decide to verify only\nthe presence of our component."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'@Test\npublic void testComplexSpecIsPresent() {\n  final ComponentContext c = mLithoViewRule.getContext();\n  final Component<FeedItemComponent> component = makeComponent("Rixty Minutes");\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, typeIs(ComplexComponent.class)));\n}\n')),(0,r.mdx)("p",null,"Clearly, having this test is better than nothing. In the same way that\nhaving some Starbucks coffee after a cross-Atlantic flight is better than no\ncoffee at all ... but I digress."),(0,r.mdx)("p",null,"What if there was a way to match just ",(0,r.mdx)("em",{parentName:"p"},"some")," of our props?"),(0,r.mdx)("h2",{id:"props-matching-with-testspec"},"Props Matching with ",(0,r.mdx)("inlineCode",{parentName:"h2"},"@TestSpec")),(0,r.mdx)("p",null,"TestSpecs allow you to match against exactly those props that you choose to\ntest. Just as LayoutSpecs and MountSpecs, TestSpecs make use of the powerful\nannotation processing mechanism Java offers and generate code for you."),(0,r.mdx)("p",null,"We start by creating a new class as part of our testing project and link to the\noriginal spec we want to generate our TestSpec for."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"@TestSpec(ComplexComponentSpec.class)\npublic interface TestComplexComponentSpec {}\n")),(0,r.mdx)("p",null,"There are a few things to note here:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"The class you reference in ",(0,r.mdx)("inlineCode",{parentName:"li"},"@TestSpec")," must be a LayoutSpec or MountSpec."),(0,r.mdx)("li",{parentName:"ul"},"You must link to the Spec and not the generated component, e.g.\n",(0,r.mdx)("inlineCode",{parentName:"li"},"ComplexComponentSpec.class")," not ",(0,r.mdx)("inlineCode",{parentName:"li"},"ComplexComponent.class"),"."),(0,r.mdx)("li",{parentName:"ul"},"In contrast to other specs, TestSpecs are generated from an interface, not a\nclass."),(0,r.mdx)("li",{parentName:"ul"},"The interface must be empty, i.e. cannot have any members."),(0,r.mdx)("li",{parentName:"ul"},"By convention, you prefix your TestSpec with ",(0,r.mdx)("inlineCode",{parentName:"li"},"Test"),", followed by the original\nspec name.")),(0,r.mdx)("p",null,"And that's it. Those two lines are enough to generate us a powerful matcher that\nwe can use in our tests."),(0,r.mdx)("h3",{id:"using-testspec"},"Using ",(0,r.mdx)("inlineCode",{parentName:"h3"},"@TestSpec")),(0,r.mdx)("p",null,"Now that we have our TestSpec generated, let's put it into use. Where normal\ncomponents have a ",(0,r.mdx)("inlineCode",{parentName:"p"},"create")," function, test specs come with a ",(0,r.mdx)("inlineCode",{parentName:"p"},"matcher")," function.\nIt does take the same props as the underlying component but, and this won't come\nas a surprise, allows omitting non-optional props."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'@Test\npublic void testComplexTestSpecProps() {\n  final ComponentContext c = mLithoViewRule.getContext();\n  final Component<FeedItemComponent> component = makeComponent("Two Brothers");\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, TestComplexComponent.matcher(c)\n          .shouldHavePuppies(false)\n          .build()));\n}\n')),(0,r.mdx)("p",null,"Obviously, this outrageous omission of puppies couldn't possibly pass the test\nrun and will fail with a helpful error message:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'java.lang.AssertionError:\nExpecting:\n <FeedItemComponent{0, 0 - 100, 100}\n  ComplexComponent{0, 0 - 100, 0}\n  Column{0, 0 - 100, 50}\n    FeedImageComponent{0, 0 - 100, 50}\n      RecyclerCollectionComponent{0, 0 - 100, 50}\n        Recycler{0, 0 - 100, 0}\n    TitleComponent{4, 46 - 16, 46}\n      Text{4, 46 - 16, 46 text="Some Name"}\n    ActionsComponent{60, 4 - 96, 40}\n      FavouriteButton{2, 2 - 34, 34 [clickable]}\n  FooterComponent{0, 50 - 100, 66}\n    Text{8, 8 - 92, 8 text="Two Brothers"}>\nto have:\n <sub component with <Sub-component of type <ComplexComponent> with\n prop <shouldHavePuppies> is <false> (doesn\'t match true)>>\n')),(0,r.mdx)("p",null,"Here we can see a brief overview of the hierarchy we were matching against and\nthe matcher that failed."),(0,r.mdx)("h3",{id:"advanced-matchers"},"Advanced Matchers"),(0,r.mdx)("p",null,"But wait, there's more! Instead of just matching against partial props, you can\nalso provide hamcrest matchers in any place that accepts concrete values. For\nprops that take resource types, you can make use of all the same matchers you\nfind in regular components."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'@Test\npublic void testComplexTestSpecAdvancedProps() {\n  final ComponentContext c = mLithoViewRule.getContext();\n  final Component<FeedItemComponent> component =\n      makeComponent("Rixty Minutes");\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, TestComplexComponent.matcher(c)\n          // titleTextSizeDip, Sp etc. work too!\n          .titleTextSizeRes(R.dimen.notification_subtext_size)\n          .title(containsString("Minutes"))\n          .build()));\n}\n')),(0,r.mdx)("h3",{id:"matching-matchers"},"Matching Matchers"),(0,r.mdx)("p",null,"There is one type of prop that requires some special treatment: components.\nWhile we could just match against child components via normal equality (and\nthere is indeed support for this), it is not particularly helpful. We rarely\nknow what exact instance of a component is passed down to the props and we face\nmany of the same problems we discussed before: The props of the Component may\nnot be known in full or perhaps we don't want to provide them all."),(0,r.mdx)("img",{src:(0,s.default)("/images/complex-component-0.svg"),align:"right",width:"200px",className:"white-background"}),(0,r.mdx)("p",null,"The solution to this is obvious: We match matchers! For any prop that takes a\nComponent, the TestSpec generates a matcher that takes another matcher. This\nallows for ",(0,r.mdx)("strong",{parentName:"p"},"declarative matching against entire trees of components"),"."),(0,r.mdx)("p",null,"For our example, let's suppose that our ",(0,r.mdx)("inlineCode",{parentName:"p"},"FeedItemComponent")," wraps the\n",(0,r.mdx)("inlineCode",{parentName:"p"},"ComplexComponent")," in a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Card"),"."),(0,r.mdx)("br",{clear:"right"}),(0,r.mdx)("br",null),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'@Test\npublic void testComplexTestSpecProps() {\n  final ComponentContext c = mLithoViewRule.getContext();\n  final Component<FeedItemComponent> component = makeComponent("Ricksy Business");\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, TestCard.matcher(c)\n          .content(TestComplexComponent.matcher(c)\n            .title(endsWith("Business"))\n            .build())\n          .build()));\n}\n')),(0,r.mdx)("p",null,"Notice the ",(0,r.mdx)("inlineCode",{parentName:"p"},"TestCard")," we use to declare our hierarchy here. The ",(0,r.mdx)("inlineCode",{parentName:"p"},"litho-testing"),"\npackage comes with TestSpecs for all standard Litho widgets."),(0,r.mdx)("h2",{id:"a-note-on-buck"},"A Note on Buck"),(0,r.mdx)("p",null,"If you use gradle, this should Just Work\u2122 and shouldn't require any additional\nsetup."),(0,r.mdx)("p",null,"With Buck or Blaze/Bazel, however, you may need some additional configuration\nfor the annotation processing step to work."),(0,r.mdx)("p",null,"In order to save you copy-pasting boilerplate all over your project, it is\nrecommended keep a rule definition like this in a well-known place\n(e.g. ",(0,r.mdx)("inlineCode",{parentName:"p"},"//tools/build_defs/android/litho_testspec.bzl"),"). You would obviously have to adjust\nthe library paths to the corresponding targets in your code base."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'"""Provides macros for working with litho testspec."""\n\ndef litho_testspec(\n  name,\n  deps=None,\n  annotation_processors=None,\n  annotation_processor_deps=None,\n  **kwargs\n):\n  """Litho testspec."""\n  deps = deps or []\n  annotation_processors = annotation_processors or []\n  annotation_processor_deps = annotation_processor_deps or []\n\n  deps.extend(\n    [\n      "//java/com/facebook/litho:litho",\n      "//third-party/android/androidx:support-v4",\n      "//libraries/components/litho-testing/src/main/java/com/facebook/litho/testing:testing",\n      "//libraries/components/litho-testing/src/main/java/com/facebook/litho/testing/assertj:assertj",\n      "//third-party/java/jsr-305:jsr-305",\n      "//third-party/java/hamcrest:hamcrest",\n      "//third-party/java/hamcrest:hamcrest-library",\n    ]\n  )\n\n  annotation_processor_deps.extend(\n    [\n      "//libraries/components/litho-processor/src/main/java/com/facebook/litho/specmodels/processor:processor-lib"\n    ]\n  )\n\n  annotation_processors.extend(\n    [\n      "com.facebook.litho.specmodels.processor.testing.ComponentsTestingProcessor",\n    ]\n  )\n\n  return android_library(\n    name,\n    deps=deps,\n    annotation_processors=annotation_processors,\n    annotation_processor_deps=annotation_processor_deps,\n    **kwargs\n  )\n')),(0,r.mdx)("p",null,"In the definitions for your test suite, you can then create a separate target\nfor your test specs:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'load("//buck_imports:litho_testspec.bzl", "litho_testspec")\n\nlitho_testspec(\n  name = "testspecs",\n  srcs = glob(["*Spec.java"]),\n  deps = [\n    "//my/library/dependencies",\n    # ...\n  ],\n)\n\nrobolectric_test(\n  name = "test",\n  srcs = glob(["*Test.java*"]),\n  deps = [\n    ":testspecs",\n    # ...\n  ]\n)\n')),(0,r.mdx)("p",null,"This ensures that test specs are processed by the dedicated\n",(0,r.mdx)("inlineCode",{parentName:"p"},"ComponentsTestingProcessor"),"."),(0,r.mdx)("h2",{id:"tldr"},"TL;DR"),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"Step 1")),(0,r.mdx)("p",null,"Create a TestSpec for your LayoutSpec or MountSpec."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},"@TestSpec(MyLayoutSpec.class)\npublic interface TestMyLayoutSpec {}\n")),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"Step 2")),(0,r.mdx)("p",null,"Use the generated test matcher in your suite."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'@Test\npublic void testComplexTestSpecAdvancedProps() {\n  final ComponentContext c = mLithoViewRule.getContext();\n  final Component<MyWrapperComponent> component = ...;\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, TestMyLayout.matcher(c)\n          .titleTextSizeRes(R.dimen.notification_subtext_size)\n          .title(containsString("Minutes"))\n          .child(TestChildComponent.matcher(c).size(greaterThan(5)).build())\n          .build()));\n}\n')))}d.isMDXComponent=!0}}]);