"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7485],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>s,MDXProvider:()=>c,mdx:()=>S,useMDXComponents:()=>d,withMDXComponents:()=>m});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e}).apply(this,arguments)}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),m=function(e){return function(t){var n=d(t.components);return i.createElement(e,o({},t,{components:n}))}},d=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=d(e.components);return i.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),m=d(n),c=a,h=m["".concat(r,".").concat(c)]||m[c]||u[c]||o;return n?i.createElement(h,l(l({ref:t},s),{},{components:n})):i.createElement(h,l({ref:t},s))}));function S(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var s=2;s<o;s++)r[s]=n[s];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},13919:(e,t,n)=>{function i(e){return!0===/^(\w*:|\/\/)/.test(e)}function a(e){return void 0!==e&&!i(e)}n.d(t,{b:()=>i,Z:()=>a})},44996:(e,t,n)=>{n.r(t),n.d(t,{useBaseUrlUtils:()=>o,default:()=>r});var i=n(52263),a=n(13919);function o(){var e=(0,i.default)().siteConfig,t=(e=void 0===e?{}:e).baseUrl,n=void 0===t?"/":t,o=e.url;return{withBaseUrl:function(e,t){return function(e,t,n,i){var o=void 0===i?{}:i,r=o.forcePrependBaseUrl,l=void 0!==r&&r,p=o.absolute,s=void 0!==p&&p;if(!n)return n;if(n.startsWith("#"))return n;if((0,a.b)(n))return n;if(l)return t+n;var m=n.startsWith(t)?n:t+n.replace(/^\//,"");return s?e+m:m}(o,n,e,t)}}}function r(e,t){return void 0===t&&(t={}),(0,o().withBaseUrl)(e,t)}},59615:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>l,contentTitle:()=>p,metadata:()=>s,toc:()=>m,default:()=>c});var i=n(87462),a=n(63366),o=(n(67294),n(3905)),r=n(44996),l={id:"custom-layout",title:"Custom Layout"},p=void 0,s={unversionedId:"custom-layout",id:"custom-layout",isDocsHomePage:!1,title:"Custom Layout",description:"Litho relies on Yoga, a powerful layout engine that is able to create very complex UIs, for layout calculations.  However, there are few exceptions where Yoga is not enough and you may need to implement your own measuring and layout.",source:"@site/../docs/custom-layout.md",sourceDirName:".",slug:"/custom-layout",permalink:"/docs/custom-layout",editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/custom-layout.md",version:"current",frontMatter:{id:"custom-layout",title:"Custom Layout"}},m=[{value:"Use cases",id:"use-cases",children:[]},{value:"Size constraints",id:"size-constraints",children:[]},{value:"Measuring a component",id:"measuring-a-component",children:[]},{value:"SizeSpec information during layout",id:"sizespec-information-during-layout",children:[]},{value:"Optimizing OnCreateLayoutWithSizeSpec",id:"optimizing-oncreatelayoutwithsizespec",children:[]}],d={toc:m};function c(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,o.mdx)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Litho relies on ",(0,o.mdx)("a",{parentName:"p",href:"https://yogalayout.com/docs/"},"Yoga"),", a powerful layout engine that is able to create very complex UIs, for layout calculations.  However, there are few exceptions where Yoga is not enough and you may need to implement your own measuring and layout."),(0,o.mdx)("p",null,"Litho provides a custom layout API for accessing size information while the ",(0,o.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/ComponentTree.html"},(0,o.mdx)("inlineCode",{parentName:"a"},"ComponentTree"))," is being created and measured, as well as the possibility to measure a component in isolation."),(0,o.mdx)("div",{className:"admonition admonition-caution alert alert--warning"},(0,o.mdx)("div",{parentName:"div",className:"admonition-heading"},(0,o.mdx)("h5",{parentName:"div"},(0,o.mdx)("span",{parentName:"h5",className:"admonition-icon"},(0,o.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,o.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"IMPORTANT")),(0,o.mdx)("div",{parentName:"div",className:"admonition-content"},(0,o.mdx)("p",{parentName:"div"}," This API comes with a ",(0,o.mdx)("strong",{parentName:"p"},"non-negligible")," performance overhead. Therefore, it is advisable to only use it when it is absolutely necessary."))),(0,o.mdx)("h2",{id:"use-cases"},"Use cases"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("strong",{parentName:"p"},"A component layout tree depends on its own and/or children's size.")," For example, perhaps a component layout should use a child only if it fits within its size constraints. If the child doesn't fit, the layout should instead use another child as a fallback.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("strong",{parentName:"p"},"Children of a container have to be absolutely positioned manually based on their/parent size.")," Yoga can absolutely position children in a parent. However, the position itself might depend on the child sizes after being measured using the parent size constraints. Margins or paddings need to be manually taken into account if required."))),(0,o.mdx)("h2",{id:"size-constraints"},"Size constraints"),(0,o.mdx)("p",null,"Before diving into the API, you should be familiar with how the ",(0,o.mdx)("a",{parentName:"p",href:"https://developer.android.com/reference/android/view/View.html#onMeasure(int,%20int)"},(0,o.mdx)("inlineCode",{parentName:"a"},"onMeasure"))," function works in a regular Android ",(0,o.mdx)("inlineCode",{parentName:"p"},"View")," and what a ",(0,o.mdx)("a",{parentName:"p",href:"https://developer.android.com/reference/android/view/View.MeasureSpec.html"},(0,o.mdx)("inlineCode",{parentName:"a"},"MeasureSpec"))," is, since Litho uses an equivalent concept called ",(0,o.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/SizeSpec.html"},(0,o.mdx)("inlineCode",{parentName:"a"},"SizeSpec")),"."),(0,o.mdx)("p",null,"Similar to the Android ",(0,o.mdx)("inlineCode",{parentName:"p"},"MeasureSpec")," equivalent, Litho's ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeSpec")," is composed of a size and a mode. The possible modes, same as for ",(0,o.mdx)("inlineCode",{parentName:"p"},"MeasureSpec"),", are: ",(0,o.mdx)("inlineCode",{parentName:"p"},"UNSPECIFIED"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"EXACTLY")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"AT_MOST"),"."),(0,o.mdx)("h2",{id:"measuring-a-component"},"Measuring a component"),(0,o.mdx)("p",null,"A component can be measured in isolation for a given ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeSpec"),". A ",(0,o.mdx)("inlineCode",{parentName:"p"},"Size")," object, passed as argument, will be populated with the resulting size."),(0,o.mdx)("p",null,"In the following example, a ",(0,o.mdx)("inlineCode",{parentName:"p"},"Text")," component is measured with unspecified ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeSpec")," implying a single line of text indefinitely long."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},"final Component<Text> textComponent = Text.create(c)\n    .textSizeSp(16)\n    .text(\u201cSome text to measure.\u201d)\n    .build();\n\nfinal Size outputSize = new Size();\ntextComponent.measure(\n    c,\n    SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n    SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n    outputSize);\n\nfinal int textComponentWidth = outputSize.width;\nfinal int textComponentHeight = outputSize.height;\n")),(0,o.mdx)("h2",{id:"sizespec-information-during-layout"},"SizeSpec information during layout"),(0,o.mdx)("p",null,"During layout creation, the API can provide information about the ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeSpecs")," a component is going to be measured with. To access this information, the ",(0,o.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/annotations/OnCreateLayoutWithSizeSpec.html"},(0,o.mdx)("inlineCode",{parentName:"a"},"@OnCreateLayoutWithSizeSpec"))," annotation needs to be used instead of ",(0,o.mdx)("inlineCode",{parentName:"p"},"@OnCreateLayout"),". The arguments of the annotated method, besides the standard ComponentContext, are two more integers representing the width spec and the height spec."),(0,o.mdx)("p",null,"In the following example, a ",(0,o.mdx)("inlineCode",{parentName:"p"},"Text")," component is measured to check if the given text fits in the available space. An ",(0,o.mdx)("inlineCode",{parentName:"p"},"Image")," component is otherwise used."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},'@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayoutWithSizeSpec\n  static Component onCreateLayoutWithSizeSpec(ComponentContext c, int widthSpec, int heightSpec) {\n\n    final Component textComponent =\n        Text.create(c).textSizeSp(16).text("Some text to measure.").build();\n\n    // UNSPECIFIED sizeSpecs will measure the text as being one line only,\n    // having unlimited width.\n    final Size textOutputSize = new Size();\n    textComponent.measure(\n        c,\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        textOutputSize);\n\n    // Small component to use in case textComponent doesn\u2019t fit within\n    // the current layout.\n    final Component imageComponent = Image.create(c).drawableRes(R.drawable.ic_launcher).build();\n\n    // Assuming SizeSpec.getMode(widthSpec) == EXACTLY or AT_MOST.\n    final int layoutWidth = SizeSpec.getSize(widthSpec);\n    final boolean textFits = (textOutputSize.width <= layoutWidth);\n\n    return textFits ? textComponent : imageComponent;\n  }\n}\n')),(0,o.mdx)("h2",{id:"optimizing-oncreatelayoutwithsizespec"},"Optimizing OnCreateLayoutWithSizeSpec"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"@CreateLayoutWithSizeSpec")," can be called more than once in cases where Yoga calls measure.  If the previous layout can be used for the new size spec this call can be avoided. Implementing the ",(0,o.mdx)("inlineCode",{parentName:"p"},"OnShouldCreateLayoutWithNewSizeSpec")," allows the spec to specify when the previous layout can be reused."),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/annotations/OnShouldCreateLayoutWithNewSizeSpec.html"},(0,o.mdx)("inlineCode",{parentName:"a"},"@OnShouldCreateLayoutWithNewSizeSpec"))," indicates that the annotated method will be called when the component checks if it can use the previous layout with a new size spec. This is used in conjunction with ",(0,o.mdx)("inlineCode",{parentName:"p"},"@OnCreateLayoutWithSizeSpec"),". The annotated method must have the following signature:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},"@OnShouldCreateLayoutWithNewSizeSpec\nstatic boolean onShouldCreateLayoutWithNewSizeSpec(\n    ComponentContext c,\n    int newWidthSpec,\n    int newHeightSpec, ...)\n")),(0,o.mdx)("p",null,"The annotated method should return ",(0,o.mdx)("inlineCode",{parentName:"p"},"true")," if and only if the Layout Spec should create a new layout for the new size spec. If the method returns ",(0,o.mdx)("inlineCode",{parentName:"p"},"false")," then the Component will use the previous layout. In addition,  outputs can be set in ",(0,o.mdx)("inlineCode",{parentName:"p"},"onCreateLayoutWithSizeSpec")," which can be referenced in ",(0,o.mdx)("inlineCode",{parentName:"p"},"onShouldCreateLayoutWithNewSizeSpec")," method as follows:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},'@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayoutWithSizeSpec\n  static Component onCreateLayoutWithSizeSpec(\n      ComponentContext c,\n      int widthSpec,\n      int heightSpec,\n      Output<Integer> textWidth,\n      Output<Boolean> didItFit) {\n\n    final Component textComponent =\n        Text.create(c).textSizeSp(16).text("Some text to measure.").build();\n\n    // UNSPECIFIED sizeSpecs will measure the text as being one line only,\n    // having unlimited width.\n    final Size textOutputSize = new Size();\n    textComponent.measure(\n        c,\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        textOutputSize);\n\n    // Small component to use in case textComponent doesn\u2019t fit within\n    // the current layout.\n    final Component imageComponent = Image.create(c).drawableRes(R.drawable.ic_launcher).build();\n\n    // Assuming SizeSpec.getMode(widthSpec) == EXACTLY or AT_MOST.\n    final int layoutWidth = SizeSpec.getSize(widthSpec);\n    final boolean textFits = (textOutputSize.width <= layoutWidth);\n\n    // set the outputs\n    textWidth.set(textOutputSize.width);\n    didItFit.set(textFits);\n\n    return textFits ? textComponent : imageComponent;\n  }\n\n  @OnShouldCreateLayoutWithNewSizeSpec\n  static boolean onShouldCreateLayoutWithNewSizeSpec(\n      ComponentContext c,\n      int newWidthSpec,\n      int newHeightSpec,\n      @FromPreviousCreateLayout int textWidth,\n      @FromPreviousCreateLayout boolean didItFit) {\n\n    final int newLayoutWidth = SizeSpec.getSize(newWidthSpec);\n    final boolean doesItStillFit = (textWidth <= newLayoutWidth);\n\n    // false if it still fits or if still doesn\'t fit\n    return doesItStillFit ^ didItFit;\n  }\n}\n')),(0,o.mdx)("img",{src:(0,r.default)("/images/flow-chart-v0.22.1-layout-with-size-spec.svg"),alt:"Layout Spec lifecycle flowchart",className:"white-background"}))}c.isMDXComponent=!0}}]);