"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6321],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>p,mdx:()=>g,useMDXComponents:()=>m,withMDXComponents:()=>c});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},o.apply(this,arguments)}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var d=a.createContext({}),c=function(e){return function(t){var n=m(t.components);return a.createElement(e,o({},t,{components:n}))}},m=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(d.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=m(n),p=i,u=c["".concat(s,".").concat(p)]||c[p]||h[p]||o;return n?a.createElement(u,r(r({ref:t},d),{},{components:n})):a.createElement(u,r({ref:t},d))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var d=2;d<o;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48112:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>r,contentTitle:()=>l,metadata:()=>d,toc:()=>c,default:()=>p});var a=n(87462),i=n(63366),o=(n(67294),n(3905)),s=["components"],r={id:"debugging-sections",title:"Debugging Sections"},l=void 0,d={unversionedId:"debugging/debugging-sections",id:"debugging/debugging-sections",isDocsHomePage:!1,title:"Debugging Sections",description:"Debugging Litho Sections Surfaces with the Flipper Sections Plugin",source:"@site/../docs/debugging/debugging-sections.md",sourceDirName:"debugging",slug:"/debugging/debugging-sections",permalink:"/docs/debugging/debugging-sections",editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/debugging/debugging-sections.md",tags:[],version:"current",frontMatter:{id:"debugging-sections",title:"Debugging Sections"},sidebar:"mainSidebar",previous:{title:"Debugging Tips",permalink:"/docs/debugging/debugging-tips"},next:{title:"Android Studio Plugin",permalink:"/docs/devtools/android-studio-plugin"}},c=[{value:"Debugging Litho Sections Surfaces with the Flipper Sections Plugin",id:"debugging-litho-sections-surfaces-with-the-flipper-sections-plugin",children:[{value:"Sections Hierarchies",id:"sections-hierarchies",children:[],level:3},{value:"Sections Terminology",id:"sections-terminology",children:[],level:3},{value:"Issues",id:"issues",children:[{value:"Issue 1: The state of an entire Section surface is getting reset",id:"issue-1-the-state-of-an-entire-section-surface-is-getting-reset",children:[],level:4},{value:"Issue 2: The section content scrolls away from top after loading",id:"issue-2-the-section-content-scrolls-away-from-top-after-loading",children:[],level:4},{value:"Issue 3: All items are being re-rendered After a data update",id:"issue-3-all-items-are-being-re-rendered-after-a-data-update",children:[],level:4},{value:"Issue 4: Section not updating items after a prop update",id:"issue-4-section-not-updating-items-after-a-prop-update",children:[],level:4}],level:3}],level:2}],m={toc:c};function p(e){var t=e.components,r=(0,i.Z)(e,s);return(0,o.mdx)("wrapper",(0,a.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("h2",{id:"debugging-litho-sections-surfaces-with-the-flipper-sections-plugin"},"Debugging Litho Sections Surfaces with the Flipper Sections Plugin"),(0,o.mdx)("p",null,"This page acts as a debugging guide that explains how to read the oerations performed when an event\noccurs in a Sections surface. This will help debug common issues, such as unwanted scrolling and\nitems getting re-rendered incorrectly."),(0,o.mdx)("h3",{id:"sections-hierarchies"},"Sections Hierarchies"),(0,o.mdx)("p",null,"In a Litho+Sections hierarchy, the common setup is to have a ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecyclerCollectionComponent")," as the\nroot of your ",(0,o.mdx)("inlineCode",{parentName:"p"},"LithoView"),". This component is the bridge with the Sections hierarchy. You'll use this\nsetup indirectly if you're using  ",(0,o.mdx)("inlineCode",{parentName:"p"},"SectionsHelper"),"."),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecyclerCollectionComponent")," wraps a ",(0,o.mdx)("inlineCode",{parentName:"p"},"Recycler")," component which mounts a ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecyclerView")," - all\nSections surfaces are just APIs to make it easier to work with ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecyclerView")," and\n",(0,o.mdx)("inlineCode",{parentName:"p"},"RecyclerView.Adapter"),". The adapter abstraction used in Sections is called a ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecyclerBinder"),". All\nadapter operations are dispatched to the ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecyclerBinder"),", which will use the render information\nimplemented by the user in the GroupSectionSpec to transform them into ",(0,o.mdx)("inlineCode",{parentName:"p"},"LithoViews")," hosting\n",(0,o.mdx)("inlineCode",{parentName:"p"},"ComponentTrees")," - these ",(0,o.mdx)("inlineCode",{parentName:"p"},"LithoViews")," represent the items inserted into the ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecyclerView.Adapter"),"."),(0,o.mdx)("p",null,"Simply put, under the hood, a Sections hierarchy is represented by a ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecyclerView")," with a single\nview type which is the ",(0,o.mdx)("inlineCode",{parentName:"p"},"LithoView"),". Each item in the list is its own ",(0,o.mdx)("inlineCode",{parentName:"p"},"ComponentTree"),"."),(0,o.mdx)("p",null,(0,o.mdx)("img",{src:n(15213).Z})),(0,o.mdx)("h3",{id:"sections-terminology"},"Sections Terminology"),(0,o.mdx)("dl",null,(0,o.mdx)("dt",null,(0,o.mdx)("strong",null,"Diffing")),(0,o.mdx)("dd",null,"Diffing means comparing the existing data on a section with an updated list passed through props or state. You will accomplish this through special Section Spec types called",(0,o.mdx)("a",{href:"/docs/sections/start"},"DiffSectionSpecs"),"."),(0,o.mdx)("dt",null,(0,o.mdx)("strong",null,"Changesets")),(0,o.mdx)("dd",null,"A changeset is a list of operations that will be dispatched to the",(0,o.mdx)("code",null,"RecyclerView Adapter")," to update the items in a list. A ",(0,o.mdx)("code",null,"Changeset"),"consists of the same type of operations supported by a ",(0,o.mdx)("code",null,"RecyclerView Adapter"),", such as insert, remove and update. Every time you recreate the Sections hierarchy by setting a new root or updating state, the framework calculates a new ",(0,o.mdx)("code",null,"Changeset")," which will have the minimal list of operations that should be performed by the ",(0,o.mdx)("code",null,"RecyclerView Adapter"),"to reflect the data changes in the UI. Without using Sections, it\u2019s the developer\u2019s responsibility to calculate granular operations for efficient updates to send to the Adapter, but the Sections API handles all of that.")),(0,o.mdx)("h3",{id:"issues"},"Issues"),(0,o.mdx)("p",null,"The following common issues can occur when using Sections, each issue has an accompanying\ndescription and walks you through how to debug them:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"#issue-1-the-state-of-an-entire-section-surface-is-getting-reset"},"Issue 1: The state of an entire Section surface is getting reset")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"#issue-2-the-section-content-scrolls-away-from-top-after-loading"},"Issue 2: The section content scrolls away from top after loading")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"#issue-3-all-items-are-being-re-rendered-after-a-data-update"},"Issue 3: All items are being re-rendered After a data update")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"#issue-4-section-not-updating-items-after-a-prop-update"},"Issue 4: Section not updating items after a prop update"))),(0,o.mdx)("p",null,"This guide includes examples of common issues that can occur when using Sections, and walks through\nhow to debug them."),(0,o.mdx)("p",null,"The code for the above issues can be found in the ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/litho/tree/master/sample/src/main/java/com/facebook/samples/litho/java/changesetdebug"},"changesetdebug"),"\nfile."),(0,o.mdx)("p",null,"To test yourself: ",(0,o.mdx)("inlineCode",{parentName:"p"},"./gradlew installDebug")," and navigate to ",(0,o.mdx)("inlineCode",{parentName:"p"},"Changeset debug")," section."),(0,o.mdx)("h4",{id:"issue-1-the-state-of-an-entire-section-surface-is-getting-reset"},"Issue 1: The state of an entire Section surface is getting reset"),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Code"),": ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/litho/blob/master/sample/src/main/java/com/facebook/samples/litho/java/changesetdebug/StateResettingActivity.java"},"StateResettingActivity")),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Scenario"),": The surface displays a ",(0,o.mdx)("inlineCode",{parentName:"p"},"StateResettingRootComponent")," which looks like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},'@OnCreateLayout\nstatic Component onCreateLayout(\n    ComponentContext c, @Prop List<DataModel> dataModels, @Prop boolean showHeader) {\n\n  final Component listComponent =\n      RecyclerCollectionComponent.create(c)\n          .disablePTR(true)\n          .section(FavouriteGroupSection.create(new SectionContext(c)).dataModels(dataModels))\n          .flexGrow(1)\n          .build();\n\n  return showHeader\n      ? Column.create(c)\n          .child(Text.create(c).text("Header").build())\n          .child(listComponent)\n          .build()\n      : listComponent;\n}\n')),(0,o.mdx)("p",null,"If ",(0,o.mdx)("inlineCode",{parentName:"p"},"StateResettingRootComponent")," can show a header, it creates a Column with a header component and\na RecyclerCollectionComponent. If the header is not ready yet, it immediately delegates to the\nRecyclerCollectionComponent. Initially the header is hidden so ",(0,o.mdx)("inlineCode",{parentName:"p"},"StateResettingRootComponent")," only\ndisplays the RecyclerCollectionComponent, but, after some time ",(0,o.mdx)("inlineCode",{parentName:"p"},"setRoot")," is called to indicate to\n",(0,o.mdx)("inlineCode",{parentName:"p"},"StateResettingRootComponent")," that the header is ready to display. This will make the header\ncomponent appear but will cause all items in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecyclerCollectionComponent")," to lose any updated\nstate and the entire list will lose its state, such as the current scroll position."),(0,o.mdx)("p",null,"In a Sections list, when an item in the list loses its state that usually indicates it was treated\nby the framework as a new item after setting new data. To investigate, look at the Changeset\noperations in the Sections Flipper plugin."),(0,o.mdx)("video",{width:"100%",controls:"controls"},(0,o.mdx)("source",{src:"/videos/debugging-sections-issue1.mov"})),(0,o.mdx)("p",null,"The following (16 seconds) video shows that when the second ",(0,o.mdx)("inlineCode",{parentName:"p"},"setRoot")," is triggered, the resulting\nChangeset for the section contains an ",(0,o.mdx)("inlineCode",{parentName:"p"},"INSERT_RANGE")," operation. Therefore, all items were\nre-rendered as new items which have just been inserted into the adapter."),(0,o.mdx)("p",null,"The resulting updated list has 20 items, but the Changeset doesn\u2019t have any DELETE operations. So\nwhere did the items you initially inserted go? This indicates there\u2019s something fishy going on with\nthe items the RecyclerBinder knows about. The RecyclerBinder has no knowledge about the items which\nwere inserted on the first render, and that can only mean one thing: a new RecyclerBinder instance\nwas created after the second ",(0,o.mdx)("inlineCode",{parentName:"p"},"setRoot"),". This can happen if the RecyclerCollectionComponent\u2019s state\nis recreated. You can confirm by adding logging in its ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/litho/blob/d23a9406659f27fa9df25d02ae1097a975973bb8/litho-sections-widget/src/main/java/com/facebook/litho/sections/widget/RecyclerCollectionComponentSpec.java#L272"},(0,o.mdx)("inlineCode",{parentName:"a"},"@OnCreateInitialState")),"\nimplementation. This means its key is changing after the ",(0,o.mdx)("inlineCode",{parentName:"p"},"setRoot")," update."),(0,o.mdx)("p",null,"Looking at the implementation of ",(0,o.mdx)("inlineCode",{parentName:"p"},"StateResettingRootComponent")," again, you see that the\n",(0,o.mdx)("inlineCode",{parentName:"p"},"RecyclerCollectionComponent")," can get re-parented depending on the presence of the header, which\nmakes the framework treat it as a different component and reset its key."),(0,o.mdx)("p",null,"The fix: To maintain the state after the ",(0,o.mdx)("inlineCode",{parentName:"p"},"setRoot")," update, you need to make the hierarchy of\ncomponents stable.  This involves making sure that the path from the root to any stateful component\nis preserved after an update. In this case, always wrapping the children in a column and\nconditionally adding the header as a child would solve the issue."),(0,o.mdx)("h4",{id:"issue-2-the-section-content-scrolls-away-from-top-after-loading"},"Issue 2: The section content scrolls away from top after loading"),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Code"),": ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/litho/blob/master/sample/src/main/java/com/facebook/samples/litho/java/changesetdebug/ScrollingToBottomActivity.java"},"ScrollingToBottomActivity")),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Scenario"),": When navigating to this Sections surface, the list is not scrolled to top.  Instead,\nit scrolls to another item automatically."),(0,o.mdx)("p",null,"Check the Flipper Sections Plugin to see what happens when navigating to this surface."),(0,o.mdx)("video",{width:"100%",controls:"controls"},(0,o.mdx)("source",{src:"/videos/debugging-sections-issue2.mov"})),(0,o.mdx)("p",null,"In the video above, the initial ",(0,o.mdx)("inlineCode",{parentName:"p"},"setRoot")," call passes to the Section a list of items, starting with\nitem 15. This matches what you see on screen. Later is a ",(0,o.mdx)("inlineCode",{parentName:"p"},"setRoot")," call which inserts at the top of\nthe Section a list of items from 0 to 14. The order in which this data is inserted explains why\nthe list scrolled to item 15."),(0,o.mdx)("p",null,"RecyclerView will try to maintain the current scroll position whenever the adapter is notified of\nchanges. In this scenario, the initial scroll position is at item \u201c15\u201d, so when the second insert\nbatch is applied, the RecyclerView will keep this as the first visible item even if items are\ninserted above."),(0,o.mdx)("p",null,"This is a commonly occuring scenario which can occur in surfaces that consist of Sections that use\ndifferent data sources - Imagine a typical feed-like surface that has a header Section followed by\nthe feed stories Section. The two Sections will receive data from different sources, each source\nbeing queried independently. This means that the response can return at different times. If the feed\nstories data is fetched first, these items will be inserted immediately, and the header data will be\ninserted at the top of the feed items later when the request completes."),(0,o.mdx)("p",null,"If your Section surface is using data queried from multiple sources, and it can be inserted out of\norder, you can maintain scroll position at the first item in the list by manually scrolling to top\nafter the data reaches the adapter using the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/communicating-with-the-ui/#scrolling-requestfocus"},(0,o.mdx)("inlineCode",{parentName:"a"},"requestFocus")," APIs"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},"@OnDataBound\nstatic void onDataBound(SectionContext c) {\n    DelayedLoadingSection.requestFocus(c, 0);\n}\n")),(0,o.mdx)("h4",{id:"issue-3-all-items-are-being-re-rendered-after-a-data-update"},"Issue 3: All items are being re-rendered After a data update"),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Code"),": ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/litho/blob/master/sample/src/main/java/com/facebook/samples/litho/java/changesetdebug/ItemsRerenderingActivity.java"},"ItemsRerenderingActivity")),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Scenario"),": Some items in the Sections list were updated after interacting with them. After some\ntime, the surface appears to blink and the scroll position is reset. All items are reset, losing any\nupdated state."),(0,o.mdx)("p",null,"This issue has similar symptoms to issue #1, but you can use the Flipper Sections Plugin this time\nto see what\u2019s different and how to find the cause."),(0,o.mdx)("video",{width:"100%",controls:"controls"},(0,o.mdx)("source",{src:"/videos/debugging-sections-issue3.mov"})),(0,o.mdx)("p",null,"The list is reset after the second setRoot call is triggered. Take a look at the changesets\ngenerated for this."),(0,o.mdx)("p",null,"All the items that were previously in the list were deleted and again inserted again, along with the\nitems that are actually new. That would explain the blinking and the state being reset, since all\nexisting items are removed and treated as completely new items."),(0,o.mdx)("p",null,"The difference between this issue and issue #1 is that the changeset contains a list of delete\noperations, which means that this is not a case of the RecyclerBinder being reset, but rather\nsomething is not working right when comparing the items in the current and new list and deciding\nif they are the same or not."),(0,o.mdx)("p",null,"Look at the code for the Section rendering this surface, which you can find in ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/litho/blob/master/sample/src/main/java/com/facebook/samples/litho/java/changesetdebug/InefficientFavouriteGroupSectionSpec.java"},"InefficientFavouriteGroupSectionSpec"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},"@OnCreateChildren\nstatic Children onCreateChildren(SectionContext c, @Prop List<DataModel> dataModels) {\n  return Children.create()\n      .child(\n          DataDiffSection.<DataModel>create(new SectionContext(c))\n              .data(dataModels)\n              .renderEventHandler(InefficientFavouriteGroupSection.onRender(c))\n              .build())\n      .build();\n}\n")),(0,o.mdx)("p",null,"The Section has a DataDiffSection child which is passed a ",(0,o.mdx)("inlineCode",{parentName:"p"},"renderEventHandler")," prop, so it knows how\nto render the ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataModel")," items but not how to compare them for efficient updates. By default, the\nSections framework will compare items first by pointer equality and then by calling ",(0,o.mdx)("inlineCode",{parentName:"p"},"equals")," if no\ncomparison methods are passed to the ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataDiffSection"),". For complex data types, you will always need\nimplement comparison methods to decide when an item should be re-rendered."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},"@OnCreateChildren\nstatic Children onCreateChildren(SectionContext c, @Prop List<DataModel> dataModels) {\n  return Children.create()\n      .child(\n          DataDiffSection.<DataModel>create(new SectionContext(c))\n              .data(dataModels)\n              .renderEventHandler(InefficientFavouriteGroupSection.onRender(c))\n              .onCheckIsSameItemEventHandler(InefficientFavouriteGroupSection.onCheckIsSameItem(c))\n              .onCheckIsSameContentEventHandler(\n                  InefficientFavouriteGroupSection.onCheckIsSameContent(c))\n              .build())\n      .build();\n}\n\n@OnEvent(RenderEvent.class)\nstatic RenderInfo onRender(SectionContext c, @FromEvent DataModel model) {\n  return ComponentRenderInfo.create()\n      .component(\n          Row.create(c)\n              .child(Text.create(c).text(model.getData()).textSizeDip(30))\n              .child(RowItem.create(c))\n              .build())\n      .build();\n}\n\n@OnEvent(OnCheckIsSameItemEvent.class)\nstatic boolean onCheckIsSameItem(\n    SectionContext c,\n    @FromEvent DataModel previousItem,\n    @FromEvent DataModel nextItem) {\n  return previousItem.getId() == nextItem.getId();\n}\n")),(0,o.mdx)("p",null,"After making the above change to ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/litho/blob/master/sample/src/main/java/com/facebook/samples/litho/java/changesetdebug/InefficientFavouriteGroupSectionSpec.java"},"InefficientFavouriteGroupSectionSpec"),",\nonly the new item is inserted and all the existing items are reused and their state is persisted."),(0,o.mdx)("p",null,(0,o.mdx)("img",{src:n(74103).Z})),(0,o.mdx)("h4",{id:"issue-4-section-not-updating-items-after-a-prop-update"},"Issue 4: Section not updating items after a prop update"),(0,o.mdx)("p",null,"Code: ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/litho/blob/master/sample/src/main/java/com/facebook/samples/litho/java/changesetdebug/PropUpdatingActivity.java"},"PropUpdatingActivity")),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Scenario"),": You have a list of items which can be in a selected or unselected state. The Section\nhas a selectedItem prop which is the index of the item which is selected - this value can change\nbased on data coming from an external source. When the value changes, a new prop value is passed\nto the Section."),(0,o.mdx)("p",null,"Initially, item at position 0 is selected:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},"SelectedItemRootComponent.create(mComponentContext)\n    .dataModels(mDataModels)\n    .selectedItem(0)\n    .build()\n")),(0,o.mdx)("p",null,"Then after a while, new data is available and item at position 1 needs to be selected:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},"SelectedItemRootComponent.create(mComponentContext)\n    .dataModels(mDataModels)\n    .selectedItem(1)\n    .build()\n")),(0,o.mdx)("p",null,"However it looks like nothing is changing - item at position 0 is still selected and item at\nposition 1 is still unselected."),(0,o.mdx)("p",null,"Again you go to the Flipper Sections Plugin to understand what\u2019s happening:"),(0,o.mdx)("video",{width:"100%",controls:"controls"},(0,o.mdx)("source",{src:"/videos/debugging-sections-issue4.mov"})),(0,o.mdx)("p",null,"Here you see that when you pass a new value for ",(0,o.mdx)("inlineCode",{parentName:"p"},"selectedItem")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"setRoot")," is called, the changeset\ngenerated for this shows us that all items in the list have been reused and nothing got updated.\nThis is not what is expected - items 0 and 1 should be updated."),(0,o.mdx)("p",null,"Similar to issue #3, this again indicates that something is not working right when comparing the\nitems in the current and new list and deciding if they are the same or not. However, looking at\n",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/litho/blob/master/sample/src/main/java/com/facebook/samples/litho/java/changesetdebug/SelectedItemRootComponentSpec.java"},(0,o.mdx)("inlineCode",{parentName:"a"},"SelectedItemRootComponent")),",\nyou see that in this case you are passing comparison methods to the DataDiffSection:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},"@OnCreateLayout\nstatic Component onCreateLayout(ComponentContext c, @Prop List<DataModel> dataModels) {\n\n  return RecyclerCollectionComponent.create(c)\n      .disablePTR(true)\n      .section(\n          DataDiffSection.<DataModel>create(new SectionContext(c))\n              .data(dataModels)\n              .renderEventHandler(SelectedItemRootComponent.onRender(c))\n              .onCheckIsSameContentEventHandler(SelectedItemRootComponent.isSameContent(c))\n              .onCheckIsSameItemEventHandler(SelectedItemRootComponent.isSameItem(c))\n              .build())\n      .flexGrow(1)\n      .build();\n}\n\n@OnEvent(RenderEvent.class)\nstatic RenderInfo onRender(\n    ComponentContext c,\n    @Prop int selectedItem,\n    @FromEvent DataModel model,\n    @FromEvent int index) {\n  return ComponentRenderInfo.create()\n      .component(\n          Row.create(c)\n              .child(Text.create(c).text(model.getData()).textSizeDip(30))\n              .child(FixedRowItem.create(c).favourited(selectedItem == index))\n              .build())\n      .build();\n}\n\n@OnEvent(OnCheckIsSameItemEvent.class)\nstatic boolean isSameItem(\n    ComponentContext context, @FromEvent DataModel previousItem, @FromEvent DataModel nextItem) {\n  return previousItem.getId() == nextItem.getId();\n}\n\n@OnEvent(OnCheckIsSameContentEvent.class)\nstatic boolean isSameContent(\n    ComponentContext context, @FromEvent DataModel previousItem, @FromEvent DataModel nextItem) {\n  return previousItem.getData().equals(nextItem.getData());\n}\n")),(0,o.mdx)("p",null,"The items in the list would only be changed based on the comparison result. However, when a new\nvalue is passed for ",(0,o.mdx)("inlineCode",{parentName:"p"},"selectedItem"),", that prop is only used in the render function and not in the\ncomparison methods - which means the items being compared will be considered the same even if the\nselection status changes."),(0,o.mdx)("p",null,"The fix in this case is to take the ",(0,o.mdx)("inlineCode",{parentName:"p"},"selectedItem")," value into account when doing the comparison.\nSince you cannot compare previous and current props, change this to make the selection  state part\nof the DataModel class. Then use that field for comparison instead.. After making that change, the\nnew comparison method would look like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},"@OnEvent(OnCheckIsSameContentEvent.class)\nstatic boolean isSameContent(\n    ComponentContext context, @FromEvent DataModel previousItem, @FromEvent DataModel nextItem) {\n  return previousItem.getData().equals(nextItem.getData())\n      && previousItem.isSelected() == nextItem.isSelected();\n}\n")),(0,o.mdx)("p",null,"This will correctly take the selection status into account when deciding whether to re-render items\nor not, and the new changeset will look like this:"),(0,o.mdx)("p",null,(0,o.mdx)("img",{src:n(80498).Z})))}p.isMDXComponent=!0},15213:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/debugging-sections-hierarchies-034085e8d2ab236c8df7eb899fb30dcd.png"},74103:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/debugging-sections-issue3-d89177f930ae45211cfa8be599805d9a.png"},80498:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/debugging-sections-issue4-be3351e85009e3a278b93b12be18615a.png"}}]);