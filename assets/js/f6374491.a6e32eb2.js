"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4826],{3905:(e,t,a)=>{a.r(t),a.d(t,{MDXContext:()=>s,MDXProvider:()=>c,mdx:()=>v,useMDXComponents:()=>u,withMDXComponents:()=>m});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(){return l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},l.apply(this,arguments)}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function d(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),m=function(e){return function(t){var a=u(t.components);return n.createElement(e,l({},t,{components:a}))}},u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,l=e.originalType,i=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),m=u(a),c=o,h=m["".concat(i,".").concat(c)]||m[c]||p[c]||l;return a?n.createElement(h,r(r({ref:t},s),{},{components:a})):n.createElement(h,r({ref:t},s))}));function v(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=a.length,i=new Array(l);i[0]=h;var r={};for(var d in t)hasOwnProperty.call(t,d)&&(r[d]=t[d]);r.originalType=e,r.mdxType="string"==typeof e?e:o,i[1]=r;for(var s=2;s<l;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},58215:(e,t,a)=>{a.r(t),a.d(t,{default:()=>o});var n=a(67294);const o=function(e){var t=e.children,a=e.hidden,o=e.className;return n.createElement("div",{role:"tabpanel",hidden:a,className:o},t)}},55064:(e,t,a)=>{a.r(t),a.d(t,{default:()=>c});var n=a(87462),o=a(67294),l=a(72389),i=a(79443);const r=function(){var e=(0,o.useContext)(i.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e};var d=a(83039),s=a(86010);const m="tabItem_1uMI";function u(e){var t,a,n,l=e.lazy,i=e.block,u=e.defaultValue,c=e.values,p=e.groupId,h=e.className,v=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),x=null!=c?c:v.map((function(e){var t=e.props;return{value:t.value,label:t.label}})),f=(0,d.duplicates)(x,(function(e,t){return e.value===t.value}));if(f.length>0)throw new Error('Docusaurus error: Duplicate values "'+f.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var y=null===u?u:null!=(t=null!=u?u:null==(a=v.find((function(e){return e.props.default})))?void 0:a.props.value)?t:null==(n=v[0])?void 0:n.props.value;if(null!==y&&!x.some((function(e){return e.value===y})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+x.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var g=r(),C=g.tabGroupChoices,b=g.setTabGroupChoices,w=(0,o.useState)(y),N=w[0],k=w[1],T=[],S=(0,d.useScrollPositionBlocker)().blockElementScrollPositionUntilNextRender;if(null!=p){var I=C[p];null!=I&&I!==N&&x.some((function(e){return e.value===I}))&&k(I)}var O=function(e){var t=e.currentTarget,a=T.indexOf(t),n=x[a].value;n!==N&&(S(t),k(n),null!=p&&b(p,n))},j=function(e){var t,a=null;switch(e.key){case"ArrowRight":var n=T.indexOf(e.currentTarget)+1;a=T[n]||T[0];break;case"ArrowLeft":var o=T.indexOf(e.currentTarget)-1;a=T[o]||T[T.length-1]}null==(t=a)||t.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.default)("tabs",{"tabs--block":i},h)},x.map((function(e){var t=e.value,a=e.label;return o.createElement("li",{role:"tab",tabIndex:N===t?0:-1,"aria-selected":N===t,className:(0,s.default)("tabs__item",m,{"tabs__item--active":N===t}),key:t,ref:function(e){return T.push(e)},onKeyDown:j,onFocus:O,onClick:O},null!=a?a:t)}))),l?(0,o.cloneElement)(v.filter((function(e){return e.props.value===N}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},v.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==N})}))))}function c(e){var t=(0,l.default)();return o.createElement(u,(0,n.Z)({key:String(t)},e))}},97399:(e,t,a)=>{a.r(t),a.d(t,{frontMatter:()=>s,contentTitle:()=>m,metadata:()=>u,toc:()=>c,default:()=>h});var n=a(87462),o=a(63366),l=(a(67294),a(3905)),i=a(55064),r=a(58215),d=["components"],s={id:"state-overview",title:"State Overview"},m=void 0,u={unversionedId:"mainconcepts/coordinate-state-actions/state-overview",id:"mainconcepts/coordinate-state-actions/state-overview",isDocsHomePage:!1,title:"State Overview",description:"This page introduces the concept of state in a Litho component.",source:"@site/../docs/mainconcepts/coordinate-state-actions/state-overview.md",sourceDirName:"mainconcepts/coordinate-state-actions",slug:"/mainconcepts/coordinate-state-actions/state-overview",permalink:"/docs/mainconcepts/coordinate-state-actions/state-overview",editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/mainconcepts/coordinate-state-actions/state-overview.md",tags:[],version:"current",frontMatter:{id:"state-overview",title:"State Overview"},sidebar:"mainSidebar",previous:{title:"Layout System with Flexbox",permalink:"/docs/mainconcepts/uicomposition/flexbox-yoga"},next:{title:"Hoisting State",permalink:"/docs/mainconcepts/coordinate-state-actions/hoisting-state"}},c=[{value:"Adding Local State to a Component",id:"adding-local-state-to-a-component",children:[],level:2},{value:"Updating State",id:"updating-state",children:[],level:2},{value:"State API Reference and Considerations",id:"state-api-reference-and-considerations",children:[{value:"Data immutability",id:"data-immutability",children:[],level:3},{value:"Component identity",id:"component-identity",children:[],level:3},{value:"Initialising state values",id:"initialising-state-values",children:[],level:3},{value:"Updating state values",id:"updating-state-values",children:[],level:3}],level:2}],p={toc:c};function h(e){var t=e.components,a=(0,o.Z)(e,d);return(0,l.mdx)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,l.mdx)("p",null,"This page introduces the concept of state in a Litho component."),(0,l.mdx)("p",null,"A Litho component can contain two types of data:"),(0,l.mdx)("ol",null,(0,l.mdx)("li",{parentName:"ol"},(0,l.mdx)("strong",{parentName:"li"}," Props"),": Props are passed down from the parent and cannot change during a component's lifecycle."),(0,l.mdx)("li",{parentName:"ol"},(0,l.mdx)("strong",{parentName:"li"}," State"),": State data is encapsulated and managed within the component, and is transparent to the parent.")),(0,l.mdx)("p",null,"Within this page, you'll consider the example of a ",(0,l.mdx)("inlineCode",{parentName:"p"},"Counter")," component, in which you can click a button to increase or decrease a value.  This example will help you to learn how to use State to make the ",(0,l.mdx)("inlineCode",{parentName:"p"},"Counter")," component reusable and encapsulated; it provides an overview of adding state to a component. You may also benefit from going through the JAVA or Kotlin State API references."),(0,l.mdx)("p",null,"You can start by encapsulating how the Counter looks:"),(0,l.mdx)(i.default,{groupId:"state-overview",defaultValue:"kotlin",values:[{label:"Kotlin API",value:"kotlin"},{label:"Spec API",value:"java"}],mdxType:"Tabs"},(0,l.mdx)(r.default,{value:"kotlin",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-kotlin"},'class CounterComponent(val counter: Int) : KComponent() {\n  override fun ComponentScope.render(): Component {\n    return Row {\n      child(Text(text = "+"))\n      child(Text(text = "" + counter))\n      child(Text(text = "-"))\n    }\n  }\n}\n'))),(0,l.mdx)(r.default,{value:"java",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-java"},'@LayoutSpec\nclass CounterComponentSpec {\n\n  @OnCreateLayout\n  static Component onCreateLayout(ComponentContext c, @Prop int count) {\n    return Row.create(c)\n        .child(Text.create(c).text("+"))\n        .child(Text.create(c).text("" + count))\n        .child(Text.create(c).text("-"))\n        .build();\n  }\n}\n')))),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"Counter")," component is missing a crucial feature, which is interacting with the buttons to update the count value."),(0,l.mdx)("p",null,"Ideally, you'd want this component to encapsulate all this behaviour in its internal implementation, which would mean you'd write it once then reuse it anywhere you need a counter, as follows:"),(0,l.mdx)(i.default,{groupId:"state-overview",defaultValue:"kotlin",values:[{label:"Kotlin API",value:"kotlin"},{label:"Spec API",value:"java"}],mdxType:"Tabs"},(0,l.mdx)(r.default,{value:"kotlin",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-kotlin"},"val counter = CounterComponent()\n"))),(0,l.mdx)(r.default,{value:"java",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-java"},"final CounterComponent counter = CounterComponent.create().build();\n")))),(0,l.mdx)("p",null,'To implement this, you need to add "state" to the ',(0,l.mdx)("inlineCode",{parentName:"p"},"Counter")," component."),(0,l.mdx)("h2",{id:"adding-local-state-to-a-component"},"Adding Local State to a Component"),(0,l.mdx)("p",null,"You can change the ",(0,l.mdx)("inlineCode",{parentName:"p"},"counter")," from prop to state in three steps:"),(0,l.mdx)("p",null,(0,l.mdx)("strong",{parentName:"p"},"1. Replace the ",(0,l.mdx)("inlineCode",{parentName:"strong"},"counter")," prop declaration with a state declaration:")),(0,l.mdx)(i.default,{groupId:"state-overview",defaultValue:"kotlin",values:[{label:"Kotlin API",value:"kotlin"},{label:"Spec API",value:"java"}],mdxType:"Tabs"},(0,l.mdx)(r.default,{value:"kotlin",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-kotlin"},"class CounterComponent() : KComponent() {\n\n  override fun ComponentScope.render(): Component {\n   val counter = useState()\n    return Row {\n      //...\n    }\n  }\n}\n"))),(0,l.mdx)(r.default,{value:"java",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-java"},"@LayoutSpec\nclass CounterComponentSpec {\n\n  @OnCreateLayout\n  static Component onCreateLayout(ComponentContext c, @State int count) {\n    return Row.create(c)\n        //...\n        .build();\n  }\n}\n")))),(0,l.mdx)("p",null,(0,l.mdx)("strong",{parentName:"p"},"2. Set an initial value for the ",(0,l.mdx)("inlineCode",{parentName:"strong"},"count")," state:")),(0,l.mdx)(i.default,{groupId:"state-overview",defaultValue:"kotlin",values:[{label:"Kotlin API",value:"kotlin"},{label:"Spec API",value:"java"}],mdxType:"Tabs"},(0,l.mdx)(r.default,{value:"kotlin",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-kotlin"},"override fun ComponentScope.render(): Component {\n   val counter = useState {1} // useState takes a lambda param to initialize the state value.\n    return Row {\n      //...\n    }\n}\n"))),(0,l.mdx)(r.default,{value:"java",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-java"},"@OnCreateInitialState\nstatic void onCreateInitialState(ComponentContext c, StateValue<Integer> count) {\n  count.set(1);\n}\n")))),(0,l.mdx)("p",null,(0,l.mdx)("strong",{parentName:"p"},"3. Use the state value")),(0,l.mdx)(i.default,{groupId:"state-overview",defaultValue:"kotlin",values:[{label:"Kotlin API",value:"kotlin"},{label:"Spec API",value:"java"}],mdxType:"Tabs"},(0,l.mdx)(r.default,{value:"kotlin",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-kotlin"},'override fun ComponentScope.render(): Component {\n    val counter = useState { 1 } // useState takes a lambda param to initialize the state value.\n    return Row {\n      child(Text(text = "+"))\n      child(Text(text = "" + counter.value))\n      child(Text(text = "-"))\n    }\n}\n'))),(0,l.mdx)(r.default,{value:"java",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-java"},'@OnCreateLayout\n  static Component onCreateLayout(ComponentContext c, @State int count) {\n    return Row.create(c)\n        .child(Text.create(c).text("+"))\n        .child(Text.create(c).text("" + count))\n        .child(Text.create(c).text("-"))\n        .build();\n  }\n')))),(0,l.mdx)("h2",{id:"updating-state"},"Updating State"),(0,l.mdx)("p",null,"Next, you'll make the Counter component update the count value when the increase or decrease buttons are clicked, in two steps:"),(0,l.mdx)("p",null,(0,l.mdx)("strong",{parentName:"p"},"1. Set click handlers on the buttons:")),(0,l.mdx)(i.default,{groupId:"state-overview",defaultValue:"kotlin",values:[{label:"Kotlin API",value:"kotlin"},{label:"Spec API",value:"java"}],mdxType:"Tabs"},(0,l.mdx)(r.default,{value:"kotlin",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-kotlin"},'override fun ComponentScope.render(): Component {\n val counter = useState { 1 } // useState takes a lambda param to initialize the state value.\n  return Row {\n    child(Text(text = "+", style = Style.onClick {}))\n    child(Text(text = "" + counter.value))\n    child(Text(text = "-", style = Style.onClick {}))\n  }\n}\n'))),(0,l.mdx)(r.default,{value:"java",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-java"},'@OnCreateLayout\n  static Component onCreateLayout(ComponentContext c, @State int count) {\n    return Row.create(c)\n        .child(Text.create(c).text("+").clickHandler(CounterComponent.onClickIncrease(c)))\n        .child(Text.create(c).text("" + count))\n        .child(Text.create(c).text("-").clickHandler(CounterComponent.onClickDecrease(c)))\n        .build();\n  }\n\n@OnEvent(ClickEvent.class)\nstatic void onClickIncrease(ComponentContext c) {}\n\n@OnEvent(ClickEvent.class)\nstatic void onClickDecrease(ComponentContext c) {}\n')))),(0,l.mdx)("p",null,(0,l.mdx)("strong",{parentName:"p"},"2. Update the state value in the click handlers:")),(0,l.mdx)(i.default,{groupId:"state-overview",defaultValue:"kotlin",values:[{label:"Kotlin API",value:"kotlin"},{label:"Spec API",value:"java"}],mdxType:"Tabs"},(0,l.mdx)(r.default,{value:"kotlin",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-kotlin",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/state/CounterComponent.kt start=start_counter end=end_counter",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/state/CounterComponent.kt",start:"start_counter",end:"end_counter"},'class CounterComponent : KComponent() {\n\n  override fun ComponentScope.render(): Component {\n    val counter = useState { 0 }\n    return Row {\n      child(\n          Text(\n              text = "+",\n              textSize = 30.dp,\n              style = Style.margin(all = 30.dp).onClick { counter.update(counter.value + 1) }))\n      child(Text(text = "${counter.value}", textSize = 30.dp, style = Style.margin(all = 30.dp)))\n      child(\n          Text(\n              text = "-",\n              textSize = 30.dp,\n              style = Style.margin(all = 30.dp).onClick { counter.update(counter.value - 1) }))\n    }\n  }\n}\n'))),(0,l.mdx)(r.default,{value:"java",mdxType:"TabItem"},(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-java",metastring:"file=sample/src/main/java/com/facebook/samples/litho/java/identity/CounterComponentSpec.java start=start_counter end=end_counter",file:"sample/src/main/java/com/facebook/samples/litho/java/identity/CounterComponentSpec.java",start:"start_counter",end:"end_counter"},'@LayoutSpec\nclass CounterComponentSpec {\n\n  @OnCreateInitialState\n  static void onCreateInitialState(ComponentContext c, StateValue<Integer> count) {\n    count.set(1);\n  }\n\n  @OnCreateLayout\n  static Component onCreateLayout(ComponentContext c, @State int count) {\n    return Row.create(c)\n        .child(Text.create(c).text("+").clickHandler(CounterComponent.onClickIncrease(c)))\n        .child(Text.create(c).text("" + count))\n        .child(Text.create(c).text("-").clickHandler(CounterComponent.onClickDecrease(c)))\n        .build();\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void onClickIncrease(ComponentContext c) {\n    CounterComponent.increase(c);\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void onClickDecrease(ComponentContext c) {\n    CounterComponent.decrease(c);\n  }\n\n  @OnUpdateState\n  static void increase(StateValue<Integer> count) {\n    count.set(count.get() + 1);\n  }\n\n  @OnUpdateState\n  static void decrease(StateValue<Integer> count) {\n    count.set(count.get() - 1);\n  }\n}\n')))),(0,l.mdx)("h2",{id:"state-api-reference-and-considerations"},"State API Reference and Considerations"),(0,l.mdx)("h3",{id:"data-immutability"},"Data immutability"),(0,l.mdx)("p",null,"Due to background layout, state can be accessed anytime by multiple threads. To ensure thread safety, state objects should be immutable (if for some rare reason this is not possible, then at least thread safe). The simplest solution is to express your state in terms of primitives since primitives are, by definition, immutable."),(0,l.mdx)("h3",{id:"component-identity"},"Component identity"),(0,l.mdx)("p",null,"Litho uses keys to keep track of component identity between layout changes and correctly identify a component as the target of a state update.\n",(0,l.mdx)("a",{parentName:"p",href:"/docs/mainconcepts/coordinate-state-actions/keys-and-identity"},"This guide")," explains in more detail how component identity works."),(0,l.mdx)("h3",{id:"initialising-state-values"},"Initialising state values"),(0,l.mdx)("p",null,"State initialisation is guaranteed to happen once and only once for a component based on its ",(0,l.mdx)("a",{parentName:"p",href:"/docs/mainconcepts/coordinate-state-actions/keys-and-identity"},"identity"),", even if there are multiple threads attempting to calculate the layout for the same component in parallel."),(0,l.mdx)("p",null,"In the Java API, the method annotated with ",(0,l.mdx)("inlineCode",{parentName:"p"},"@OnCreateInitialState")," is guaranteed to be called just once during a component's lifecycle."),(0,l.mdx)("p",null,"This is an important consideration that you should keep in mind when you use prop values to initialize state. Passing new props to a component will not call the initializer again; a state value can only be updated after it was initialized by using the ",(0,l.mdx)("a",{parentName:"p",href:"/docs/mainconcepts/coordinate-state-actions/state-overview#updating-state"},"state update APIs"),"."),(0,l.mdx)("p",null,"In the Java API, to set an initial value for a state, you have to write a method annotated with ",(0,l.mdx)("inlineCode",{parentName:"p"},"@OnCreateInitialState")," in your spec.\nThe following are points to keep in mind when writing an ",(0,l.mdx)("inlineCode",{parentName:"p"},"@OnCreateInitialState")," method:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"The first parameter must be of type ",(0,l.mdx)("inlineCode",{parentName:"li"},"ComponentContext"),"."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"@Prop")," parameters are allowed, but ",(0,l.mdx)("inlineCode",{parentName:"li"},"@OnCreateInitialState")," methods will not be called again if the props change."),(0,l.mdx)("li",{parentName:"ul"},"All other parameters must have a corresponding parameter annotated with ",(0,l.mdx)("inlineCode",{parentName:"li"},"@State")," in the other lifecycle methods, and their type must be a ",(0,l.mdx)("a",{parentName:"li",href:"pathname:///javadoc/com/facebook/litho/StateValue.html"},"StateValue")," that is parameterized with the type of the matching ",(0,l.mdx)("inlineCode",{parentName:"li"},"@State")," element."),(0,l.mdx)("li",{parentName:"ul"},"Initializing a state value is not mandatory, and implementing an ",(0,l.mdx)("inlineCode",{parentName:"li"},"@OnCreateInitialState")," method can be entirely skipped. If a state value is not explicitly initialised, the initial state will be assigned the default value of its inferred type, for example ",(0,l.mdx)("inlineCode",{parentName:"li"},"0")," for integer state, ",(0,l.mdx)("inlineCode",{parentName:"li"},"false")," for boolean state or ",(0,l.mdx)("inlineCode",{parentName:"li"},"null")," for Objects."),(0,l.mdx)("li",{parentName:"ul"},"You should never need to call the ",(0,l.mdx)("inlineCode",{parentName:"li"},"@OnCreateInitialState")," method yourself.")),(0,l.mdx)("h3",{id:"updating-state-values"},"Updating state values"),(0,l.mdx)("p",null,"Every state update  will trigger a new layout calculation for its ",(0,l.mdx)("inlineCode",{parentName:"p"},"ComponentTree"),". Passing new props to a Litho component and updating the state are implemented in the same way in Litho, so there is no performance difference. Take a look at ",(0,l.mdx)("a",{parentName:"p",href:"/docs/best-practices/props-vs-state"},"this guide")," to understand when you should update a Component using new props or updating state."),(0,l.mdx)("p",null,"However, Litho implements a feature called reconciliation, which attempts to detect what part of the ",(0,l.mdx)("inlineCode",{parentName:"p"},"ComponentTree")," is affected by that state update and reuse the layout for the nodes that don't need to change.\nState updates can be performed synchronously on the same thread that they were triggered from, or asynchronously from Litho's background thread."),(0,l.mdx)("p",null,"The following points should be kept in mind when updating a state value:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"Avoid calling state update methods in the render method of a component (",(0,l.mdx)("inlineCode",{parentName:"li"},"@OnCreateLayout")," methods in the Java API or the ",(0,l.mdx)("inlineCode",{parentName:"li"},"render")," function in the Kotlin API).\nEvery state update method will trigger a new layout calculation, which re-invokes the render method of the component that triggered the state update. This can easily lead to an infinte loop. You should consider whether a ",(0,l.mdx)("a",{parentName:"li",href:"/docs/mainconcepts/coordinate-state-actions/state-overview#lazy-state-updates"},"lazy state update")," wouldn't be more appropriate for your use case, and only use state updates in a render method if you're absolutely certain that the state update is conditionally called and can only be triggered a limited number of times."),(0,l.mdx)("li",{parentName:"ul"},"In ",(0,l.mdx)("a",{parentName:"li",href:"/docs/mainconcepts/uicomposition/mount-specs"},"MountSpecs"),", state updates are not allowed in ",(0,l.mdx)("inlineCode",{parentName:"li"},"bind")," and ",(0,l.mdx)("inlineCode",{parentName:"li"},"mount")," methods and will cause a runtime exception if used. If you need to update a state value in those methods, you should instead use a ",(0,l.mdx)("a",{parentName:"li",href:"/docs/mainconcepts/coordinate-state-actions/state-overview#lazy-state-updates"},"lazy state update"),".")),(0,l.mdx)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.mdx)("div",{parentName:"div",className:"admonition-heading"},(0,l.mdx)("h5",{parentName:"div"},(0,l.mdx)("span",{parentName:"h5",className:"admonition-icon"},(0,l.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,l.mdx)("div",{parentName:"div",className:"admonition-content"},(0,l.mdx)("p",{parentName:"div"},"In the Java API, you can define how a component's state or states should be updated by declaring methods annotated with ",(0,l.mdx)("inlineCode",{parentName:"p"},"@OnUpdateState")," in the specs.\nYou can have as many ",(0,l.mdx)("inlineCode",{parentName:"p"},"@OnUpdateState")," methods as you need, according to what states you want to update or what parameters your states depend on.\nThe following points should be considered when writing an ",(0,l.mdx)("inlineCode",{parentName:"p"},"@OnUpdateState")," method:"),(0,l.mdx)("ul",{parentName:"div"},(0,l.mdx)("li",{parentName:"ul"},"Parameters representing the state values must match the name of a parameter annotated with ",(0,l.mdx)("inlineCode",{parentName:"li"},"@State")," and used in other lifecycle methods, and their type must be a ",(0,l.mdx)("inlineCode",{parentName:"li"},"StateValue")," parameterized with the type of the matching ",(0,l.mdx)("inlineCode",{parentName:"li"},"@State"),"."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"@Prop")," are not allowed, but ",(0,l.mdx)("inlineCode",{parentName:"li"},"@Param")," parameters are. If the value of your state depends on props, you can pass them as ",(0,l.mdx)("inlineCode",{parentName:"li"},"@Param")," params from the lifecycle methods that call the state update methods.\nFor each ",(0,l.mdx)("inlineCode",{parentName:"li"},"@OnUpdateState")," method in your spec, the generated component will have two methods that will delegate to the ",(0,l.mdx)("inlineCode",{parentName:"li"},"@OnUpdateStUpdate the state value in the click handlerate")," method under the hood:"),(0,l.mdx)("li",{parentName:"ul"},"A static method with the same name, which will asynchronously apply the state updates."),(0,l.mdx)("li",{parentName:"ul"},"A static method with the same name and a ",(0,l.mdx)("em",{parentName:"li"},"Sync")," suffix, which will synchronously trigger the state updates.\nBoth methods take a ",(0,l.mdx)("inlineCode",{parentName:"li"},"ComponentContext")," as first parameter, followed by all the parameters declared with ",(0,l.mdx)("inlineCode",{parentName:"li"},"@Param")," in your ",(0,l.mdx)("inlineCode",{parentName:"li"},"@OnUpdateState")," method.")),(0,l.mdx)("h2",{parentName:"div",id:"lazy-state"},"Lazy state"),(0,l.mdx)("p",{parentName:"div"},"For situations where you want to update the value of a state but don't need to immediately trigger a new layout calculation, you can use ",(0,l.mdx)("strong",{parentName:"p"},"lazy state updates"),". After a lazy state update, the new state value will be visible in event handlers, but a new layout will not be triggered.\nCurrently, the value is immediately visible to the event handler but ",(0,l.mdx)("strong",{parentName:"p"},"not")," visible to other lifecycle callbacks (such as ",(0,l.mdx)("inlineCode",{parentName:"p"},"onMount"),")."),(0,l.mdx)("p",{parentName:"div"},"Lazy state is useful for updating state values that don't need to be reflected in the UI. For example, say you want to log an analytics event only the first time a component becomes visible. If you use lazy state, you can record whether a log was sent in a lazy state variable without causing the UI to reflow."),(0,l.mdx)("p",{parentName:"div"},"Lazy state can still be used for regular state updates."),(0,l.mdx)(i.default,{groupId:"state-overview",defaultValue:"kotlin",values:[{label:"Kotlin API",value:"kotlin"},{label:"Spec API",value:"java"}],mdxType:"Tabs"},(0,l.mdx)(r.default,{value:"kotlin",mdxType:"TabItem"},(0,l.mdx)("pre",{parentName:"div"},(0,l.mdx)("code",{parentName:"pre",className:"language-kotlin",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/state/IdentityRootComponent.kt start=start_use_ref end=end_use_ref",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/state/IdentityRootComponent.kt",start:"start_use_ref",end:"end_use_ref"},"val logOnce = useRef { false }\n// start_manual_key\nreturn Column(\n    style =\n        Style.onVisible {\n          if (!logOnce.value) {\n            // do some logging\n            logOnce.value = true\n          }\n")),"  "),(0,l.mdx)(r.default,{value:"java",mdxType:"TabItem"},(0,l.mdx)("pre",{parentName:"div"},(0,l.mdx)("code",{parentName:"pre",className:"language-java",metastring:"file=sample/src/main/java/com/facebook/samples/litho/java/identity/IdentityRootComponentSpec.java start=start_lazy_state end=end_lazy_state",file:"sample/src/main/java/com/facebook/samples/litho/java/identity/IdentityRootComponentSpec.java",start:"start_lazy_state",end:"end_lazy_state"},"@OnEvent(VisibleEvent.class)\nstatic void onClickEvent(ComponentContext c, @State(canUpdateLazily = true) boolean logOnce) {\n  if (!logOnce) {\n    // do some logging\n    IdentityRootComponent.lazyUpdateLogOnce(c, true);\n  }\n}\n")),"  ")))))}h.isMDXComponent=!0}}]);